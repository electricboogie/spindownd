#!/bin/bash

PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'

# Change working directory to / to prevent the daemon from holding a mounted filesystem open.
cd /

function _spindownd {

# Set timeout
local TIMEOUT=1800

# Set initial polling interval to actual, and add multiplier to use when in standby
local INITIAL_POLLING_INTERVAL=30
local STANDBY_MULTIPLIER=4
local ACTUAL_POLLING_INTERVAL=$INITIAL_POLLING_INTERVAL

# Array of disks we want watched
local watchdisks=(
sda
sdb
sdc
)

# Main daemon loop
while true
do
 # Loop through all the array disks and spin down the idle disks. Will find all drives sda -> sdz AND sdaa -> sdaz...
 for disk in "${watchdisks[@]}"
 do

  # Check if drive does not exist, if not, then exit
  if [ ! -e /dev/$disk ]; then
   continue
  fi

  # Create a files on the ramdisk and cycle them to test for disk activity
  # Create the origin stats, if removed b/c non-idle
  if [ ! -f "/dev/shm/diskstats_origin_$disk" ]
  then
   cat /proc/diskstats | grep "$disk" > "/dev/shm/diskstats_origin_$disk"
  fi
  # Always recreate the new stats
  cat /proc/diskstats | grep "$disk" > "/dev/shm/diskstats_new_$disk"
  
  # Check file last modified time/date
  local NEW_POLL=$( stat -c %Y "/dev/shm/diskstats_new_$disk" )
  local ORIGIN_POLL=$( stat -c %Y "/dev/shm/diskstats_origin_$disk" )
  local DIFF_POLL=$(( $NEW_POLL - $ORIGIN_POLL ))

  # Test possible drive states and execute appropriate action:
  
  # 1) Non-idle (clear diskstats and start over)
  if [[ "$( diff /dev/shm/diskstats_origin_$disk /dev/shm/diskstats_new_$disk )" != "" ]]
  then
   rm "/dev/shm/diskstats_origin_$disk"
   #echo "Disk has NOT been IDLE during the polling period.  Resetting polling for disk: /dev/$disk"
  # 2) Standby (increase polling interval) 
  elif [[ $( smartctl -n standby /dev/$disk | grep -c "STANDBY" ) -ne 0 ]]
  then
   local ACTUAL_POLLING_INTERVAL=$(( $STANDBY_MULTIPLIER * $INITIAL_POLLING_INTERVAL ))
   #echo "/dev/$disk is already sleeping. New polling interval is $ACTUAL_POLLING_INTERVAL seconds."
  # 3) Idle, but not timed out (do nothing) 
  elif [[ $DIFF_POLL -lt $TIMEOUT ]]
  then
   local SECONDS_TO_TIMEOUT=$(($TIMEOUT - $DIFF_POLL))
   #echo "Disk is IDLE but has not reached its TIMEOUT yet.  Continuing to poll disk: /dev/$disk.  Timeout in $SECONDS_TO_TIMEOUT seconds"
  # 4) Idle and timed out (force standby disk)
  else
   rm "/dev/shm/diskstats_origin_$disk"
   smartctl --set=standby,now /dev/$disk > /dev/null
   echo "Disk has been IDLE for the timeout period.  Spinning down disk: /dev/$disk"
  fi
 done

# Sleep for polling interval period
sleep $ACTUAL_POLLING_INTERVAL
# And then reset to default
local ACTUAL_POLLING_INTERVAL=$INITIAL_POLLING_INTERVAL

done
}

_spindownd  2>&1 | /usr/bin/logger -t spindownd &
